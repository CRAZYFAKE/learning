[TOC]



# 基本语法

# 面向对象

## 类

### 构造函数和析构函数

使用方法：

```php
class Construct {
    // 构造函数，可以传参数
	public function __construct($type = 0) {
		echo "构造方法传入参数 \$type => {$type}<br>";
	}
    // 析构函数
	public function __destruct() {
		echo "析构方法";
	}
}
```

手动调用析构函数使用`unset()`方法

## 继承

> 建议使用对象组合，来达到类的扩展性。不能滥用继承，继承不建议超过三层。
>
> 这点得慢慢体会，暂时还没有发现有什么问题

1. 继承子类可以拥有父类除private修饰词修饰的意外的属性和方法（此处涉及到private、public、protected修饰词的权限控制）

2. 函数名相同时，子类会重写父类的方法

3. 构造方法：

   1) 实例化子类，如果子类没有构造方法时，会调用父类的构造方法，如果有构造方法，则调用自己的构造

   2) 子类想调用父类的构造方法时，使用关键字parent

4. `final`关键字

   1) `class`前使用final，则类不能被继承

   2)`function`前使用final，则方法不能被重写





# 命名空间

1. 同一命名空间下，不能出现重复的类名

2. 类、接口、函数和常量受到命名空间的影响

3. `define()` 为全局常量，不受命名空间影响

4. 使用use导入命名空间下的类

5. 如果导入了不同命名空间下的两个相同名称相同的类，使用别名as，如 

   ```Php
   use vender\Imooc as Imooc2;
   ```

6. 同样可以使用use 导入function和常量

   ```php
   use function vender\session\like;
   use const vender\session\IMOOC;
   ```

7. 如果没有使用namespace指定当前脚本的命名空间的话，当前脚本是全局命名空间的

8. 如何在局部命名空间，调用全局命名空间的类和函数呢？

   - 使用反斜杠`\Test()`，意思是告诉PHP，使用全局作用域下的class Test

   - 如果不加反斜杠()的话

     如果是变量和函数，会首先在当前命名空间下寻找变量和函数的定义，如果没有的话，再去全局命名空间找。

     如果是类的话，会直接在当前命名空间下寻找

# 自动加载

## __autoload()

使用`__autoload()`函数

当当前文件没有Imooc6类时，会执行__autoload函数，传入实例化类的名字Imooc6

但是并不常用。

```php
function __autoload($className) {
	require $className . ".php";
}
```

## spl_autoload_register

```php
spl_autoload_register(function ($className){
	require $className . ".php";
});

spl_autoload_register(function ($className) {
	include str_replace("\\", "/", $className . ".php");
});
```

# static关键字

1. 类的属性和方法，不是对象的

2. 不能在static函数 调用非static属性

3. 子类调用父类的static属性或方法：

   使用关键字`parent`