[TOC]

# 一. node 特点:

1. 异步I/O, 类似于ajax请求
2. 事件与回调函数
   异步请求, 回调函数接收结果
3. 单线程
   弊端: 无法利用多核cpu; 错误引起整个应用退出;  大量计算占用cpu导致无法调用异步I/O
   好处: 不在意同步状态; 没有死锁的概念; 没有上下文切换所带来的性能上的开销
   出现大量计算时, node使用子进程来解决这个问题 child_process, 再通过进程间时间消息来传递结果
4. 跨平台
   在微软的帮助下, 能够在Windows平台上运行

# 二. 模块机制

1. CommonJS规范, 希望js能够在任何地方运行

2. Node借鉴CommonJS的Modules规范实现的

3. CommonJS模块规范

   1. 模块引用, require
   2. 模块定义, 提供了 exports 对象用于导出变量和方法, exports是module的一个属性

   ​    exports 和 module.exports 的区别

   3. 模块标识

4. Node 模块实现
   1) 引入模块分为三个步骤: 路径分析; 文件定位; 编译执行
   ​    核心模块: Node 源码编译时, 编译进了二进制执行文件. 所以省略了 文件定位 和 编译执行, 并且在路径
   ​    分析中优先判断, 所以它的速度是最快的
   ​    文件模块: 在运行时加载. 速度比核心模块慢
   2) 优先从缓存中加载模块
   ​    路径分析 ==>>
   ​    路径分析, 也就是模块标识符分析, 标识符分为: 核心模块, 相对路径, 绝对路径, 非路径形式的文件模块
   ​    模块加载优先级: 核心模块缓存 > 文件模块缓存 > 核心模块 > 路径形式的文件模块 > 自定义模块
   ​    模块路径 : 查找方式是 沿路径向上逐级递减, 直到根目录下的 node_modules 目录
   ​    文件定位: 扩展名分析, 按照 .js / .json / .node 的次序补足扩展名, 依次尝试
   ​    模块编译 ==>>
   ​    编译和执行是引入文件模块后的最后一个阶段, 
   ​    不同文件的载入方式 =>
   ​    .js 文件. 通过 fs 模块同步读取文件然后执行
   ​    .node 文件. 这是用C/C++编写的扩展文件, 通过 dlopen() 方法加载最后编译生成的文件
   ​    .json 文件. 通过 fs 模块同步读取文件后, 用 JSON.parse() 结果分析
   ​    其余扩展文件. 被当做 .js 文件载入
   ​    通过 require.extensions 可以知道系统中已有的扩展加载方式, 
   ​    1) js模块的编译
   ​        防止污染全局变量, Node 对获取的 JavaScript 文件内容进行了包装, 在头部加入了
   ​        (function (exports, require, module, __filename, __dirname){ \n , 在尾部添加了 \n}); 
   ​        exports 对象是通过形参的方式传入, 直接赋值形参会改变形参的引用, 但是不能改变作用域外的值
   ​    2) c/c++ 模块的编译
   ​        Node 调用 process.dlopen() 方法进行加载和执行.
   ​        .node 文件并不需要编译, 只有 加载 和 执行 的过程
   ​    3) JSON 文件编译
   ​        通过 fs 同步读取 JSON, 调用 JSON.parse() 得到对象, 然后赋值给 exports
   ​    TIP : 如果知道文件后缀名为JSON, 那么直接调用 require(‘XX.json’) 引入, 会有性能的提升

## 2.3 核心模块

   >  C/C++ 文件存放在Node项目的 src 目录下, JS 文件存放在 lib 目录下

### 2.3.1 JS核心模块的编译过程

   1. 转存为C/C++代码

      Node采用V8附带的 js2c.py工具, 将内置的 js 代码 ( src/node.js 和 lib/*.js ) 转换为C++的数组, 生成 node_natives.h 头文件

      在启动 Node 进程时, js 代码直接加载进内存, 比普通的文件模块的加载要快的多

   2. 编译 js 核心模块

### 2.3.2 C/C++核心模块的编译过程

   > C/C++ 完成核心部分, 其他部分由 js 实现包装或导出, 如buffer / crypto / evals / fs / os 等模块
   >
   > 这里将 纯C/C++编写的部分统一称为 **內建模块**

   1. 內建模块的组织形式

      在 node_extension.h 文件统一放进了一个叫 node_module_list 的数组中.

      內建模块的优势 : 

      1) 由C/C++编写，性能优于脚本语言

      2) 被编译进二进制文件，一点Node开始执行，它们会被加载都内存中，而且是可直接执行

   2. 内建模块的导出

      1）模块直接依赖层级关系：

      内建模块( C/C++ ) => 核心模块（JavaScript） => 文件模块 

      2）不推荐文件模块直接调用内建模块，直接调用核心模块即可

      3）内建模块 是如何将内部变量和方法导出的，以供外部JavaScript调用的呢？

      生存全局变量process => 提供Binding()方法加载内部模块 => 创建空的exports对象 => 调用 get_builtin_module() 方法取出内建对象 => 执行 register_func() 填充 exports 对象 => 最后将exports对象按模块名称缓存

### 2.3.3 核心模块的引入流程

### 2.3.4 编写核心模块

## 2.4 C/C++扩展模块

> C/C++ 模块通过预编译为.node文件，然后调用process.dlopen()方法加载执行。
>
> Linux下 需要 g++/gcc 编译为 .so 文件
>
> Windows下 需要 Visual C++ 编译为 .dll 文件

### 2.4.1 前提条件

1. GYP项目生成工具
2. V8引擎C++库
3. libuv库
4. Node内部库
5. 其他库：在deps目录下的，zlib、openssl、http_parser等

### 2.4.2 C/C++扩展模块的编写

### 2.4.3 C扩展的编译

1. 编写 binding.gyp文件
2. 调用 node-gyp configure
3. 执行 node-gyp build

生成的.node文件在 build/Release目录下

### 2.4.4 C扩展的加载

`var hello = require('./build/Release/hello.node')`

# 三. 异步I/O

>Linux: v0.9.3之前使用的是 libeio, 之后使用的自行实现了线程池 Thread Poll
>
>Windows: 方案为 IOCP, 线程池由系统内核管理
>
>Node 在编译期间会判断平台条件, 选择性编译 unix 目录或是 win 目录下的源码

*nix 下的 I/O, 不仅仅限于磁盘文件的读写, 还包括硬件/套接字等几乎所有的计算机资源都被抽象为了文件.



## 3.3 Node 异步I/O

> 异步I/O环节由 事件循环 / 观察者 / 请求对象组成

### 3.3.1 事件循环

Node自身的执行模型 - 事件循环

每执行一次循环过程我们称之为 `Tick` , 具体流程如下 : 

1. 是否有事件 :  <是> 继续执行2 ;  <否>退出
2. 取出一个事件
3. 是否有关联回调 : <是>执行回调 执行4 ; <否>直接执行4
4. 进如下个循环 

### 3.3.2 观察者



### 3.3.3 请求对象



# 四. 异步编程

# 五. V8的垃圾回收机制与内存限制

> V8内存限制, Node 通过 js 使用内存时只能使用部分内存, 64位下约为1.4GB, 32位下约为0.7GB

## 5.1垃圾回收机制和内存限制

### 5.1.4 V8的垃圾回收

1. 主要的回收算法

   > 回收策略主要基于分代式垃圾回收
   >
   > 新生代的对象为存活时间较短的对象，老生代的对象是存活时间较长或常驻内存的对象。
   >
   > 不同代的对象采用不同的算法进行垃圾回收。新生代采用scavenge算法，老生代采用mark-sweep&mark-compact算法

   内存分代: 新生代内存空间 和 老生代内存空间

   |        | 64位系统 | 32位系统 |
   | ------ | -------- | -------- |
   | 老生代 | 1400MB   | 700MB    |
   | 新生代 | 32MB     | 16MB     |
   | 最大值 | 1464MB   | 732MB    |

   默认情况下, V8堆内存最大值在64位上为 1464MB, 在32位上为 732MB

2. Scavenge算法

   这是一种采用复制的方式实现内存回收的算法。具体采用 Cheney 算法.

   它将堆内存分为两部分，from空间和to空间。分配对象内存时在from空间进行，to空间处于闲置状态。

   

   当开始垃圾回收时复制from空间中的存活对象到to空间去，非存活对象占用的空间会被释放掉。

   >复制的过程中需要进行检查, 将符合两个条件的对象, 移动到老代区, 也叫做晋升
   >
   >条件一 : 对象是否经理过Scavenge回收
   >
   >条件二 : To空间的内存占用比例是否超过 25%

   完成后，两个空间角色互换。

   

   很显然，这是一种典型的牺牲空间换取时间的算法。新生代对象的生命周期较短且存活对象只占少部分，因此这个算法很适合新生代。

3. Mark-Sweep & Mark-Compact

   > Mark-Sweep [标记清除], 分为 **标记** 和 **清除** 两个阶段
   >
   > Mark-Compact [标记整理], 为了解决 Mark-Sweep清理内存之后, 出现内存不连续, 内存碎片问题

   由于 Mark-Compact 需要移动对象, 所以执行效率不是很快, 因此V8主要采用 Mark-Sweep, 在内存空间不足以对从新生代中晋升过来的对象进行分配时, 才使用 Mark-Compact

    Mark-Sweep算法就是一般意义上的标记清除，标记阶段标记存活的对象，清除阶段清除没有被标记的对象。这个算法最大的问题就是内存碎片问题

   Mark-Compact就是为了解决这个问题而提出的，即标记整理。标记整理，顾名思义就是说在标记后整理存活的对象，将其往一端移动，移动完成后，清理掉死亡对象。

4. Incremental Marking

   > 增量式整理

   上述3种算法的执行都需要将应用逻辑暂停下来，等到垃圾回收执行完再恢复应用逻辑，这样的行为称为全停顿（stop-the-world）。

   这样的操作应用于新生代垃圾回收时影响不大，但是老生代就不一样了，内存配置得大，存活对象也多，全堆垃圾回收时造成应用的停顿就会比较长了。

   改善方法有增量标记（incremental marking）、延迟清理（lazy sweeping）和增量式整理（incremental compaction），同时还有并行标记和并行清理，这是利用多核进行性能优化。



## 5.2 高效使用内存

在V8面前, 开发者所要具备的责任是如何让垃圾回收机制更高效地工作

### 5.2.1 作用域

