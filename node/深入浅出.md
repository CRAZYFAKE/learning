[TOC]

# 一. node 特点:

1. 异步I/O, 类似于ajax请求
2. 事件与回调函数
   异步请求, 回调函数接收结果
3. 单线程
   弊端: 无法利用多核cpu; 错误引起整个应用退出;  大量计算占用cpu导致无法调用异步I/O
   好处: 不在意同步状态; 没有死锁的概念; 没有上下文切换所带来的性能上的开销
   出现大量计算时, node使用子进程来解决这个问题 child_process, 再通过进程间时间消息来传递结果
4. 跨平台
   在微软的帮助下, 能够在Windows平台上运行

# 二. 模块机制

1. CommonJS规范, 希望js能够在任何地方运行

2. Node借鉴CommonJS的Modules规范实现的

3. CommonJS模块规范

   1. 模块引用, require
   2. 模块定义, 提供了 exports 对象用于导出变量和方法, exports是module的一个属性

   ​    exports 和 module.exports 的区别

   3. 模块标识

4. Node 模块实现
   1) 引入模块分为三个步骤: 路径分析; 文件定位; 编译执行
   ​    核心模块: Node 源码编译时, 编译进了二进制执行文件. 所以省略了 文件定位 和 编译执行, 并且在路径
   ​    分析中优先判断, 所以它的速度是最快的
   ​    文件模块: 在运行时加载. 速度比核心模块慢
   2) 优先从缓存中加载模块
   ​    路径分析 ==>>
   ​    路径分析, 也就是模块标识符分析, 标识符分为: 核心模块, 相对路径, 绝对路径, 非路径形式的文件模块
   ​    模块加载优先级: 核心模块缓存 > 文件模块缓存 > 核心模块 > 路径形式的文件模块 > 自定义模块
   ​    模块路径 : 查找方式是 沿路径向上逐级递减, 直到根目录下的 node_modules 目录
   ​    文件定位: 扩展名分析, 按照 .js / .json / .node 的次序补足扩展名, 依次尝试
   ​    模块编译 ==>>
   ​    编译和执行是引入文件模块后的最后一个阶段, 
   ​    不同文件的载入方式 =>
   ​    .js 文件. 通过 fs 模块同步读取文件然后执行
   ​    .node 文件. 这是用C/C++编写的扩展文件, 通过 dlopen() 方法加载最后编译生成的文件
   ​    .json 文件. 通过 fs 模块同步读取文件后, 用 JSON.parse() 结果分析
   ​    其余扩展文件. 被当做 .js 文件载入
   ​    通过 require.extensions 可以知道系统中已有的扩展加载方式, 
   ​    1) js模块的编译
   ​        防止污染全局变量, Node 对获取的 JavaScript 文件内容进行了包装, 在头部加入了
   ​        (function (exports, require, module, __filename, __dirname){ \n , 在尾部添加了 \n}); 
   ​        exports 对象是通过形参的方式传入, 直接赋值形参会改变形参的引用, 但是不能改变作用域外的值
   ​    2) c/c++ 模块的编译
   ​        Node 调用 process.dlopen() 方法进行加载和执行.
   ​        .node 文件并不需要编译, 只有 加载 和 执行 的过程
   ​    3) JSON 文件编译
   ​        通过 fs 同步读取 JSON, 调用 JSON.parse() 得到对象, 然后赋值给 exports
   ​    TIP : 如果知道文件后缀名为JSON, 那么直接调用 require(‘XX.json’) 引入, 会有性能的提升

   ## 2.3 核心模块

   >  C/C++ 文件存放在Node项目的 src 目录下, JS 文件存放在 lib 目录下

   ### 2.3.1 JS核心模块的编译过程

   1. 转存为C/C++代码

      Node采用V8附带的 js2c.py工具, 将内置的 js 代码 ( src/node.js 和 lib/*.js ) 转换为C++的数组, 生成 node_natives.h 头文件

      在启动 Node 进程时, js 代码直接加载进内存, 比普通的文件模块的加载要快的多

   2. 编译 js 核心模块

   ### 2.3.2 C/C++核心模块的编译过程

   > C/C++ 完成核心部分, 其他部分由 js 实现包装或导出, 如buffer / crypto / evals / fs / os 等模块
   >
   > 这里将 纯C/C++编写的部分统一称为 **內建模块**

   1. 內建模块的组织形式

      在 node_extension.h 文件统一放进了一个叫 node_module_list 的数组中.

      內建模块的优势 : 

      1) 由C/C++编写，性能优于脚本语言

      2) 被编译进二进制文件，一点Node开始执行，它们会被加载都内存中，而且是可直接执行

   2. 内建模块的导出

      1）模块直接依赖层级关系：

      内建模块( C/C++ ) => 核心模块（JavaScript） => 文件模块 

      2）不推荐文件模块直接调用内建模块，直接调用核心模块即可

      3）内建模块 是如何将内部变量和方法导出的，以供外部JavaScript调用的呢？

      生存全局变量process => 提供Binding()方法加载内部模块 => 创建空的exports对象 => 调用 get_builtin_module() 方法取出内建对象 => 执行 register_func() 填充 exports 对象 => 最后将exports对象按模块名称缓存

### 2.3.3 核心模块的引入流程

### 2.3.4 编写核心模块

## 2.4 C/C++扩展模块

> C/C++ 模块通过预编译为.node文件，然后调用process.dlopen()方法加载执行。
>
> Linux下 需要 g++/gcc 编译为 .so 文件
>
> Windows下 需要 Visual C++ 编译为 .dll 文件

### 2.4.1 前提条件

1. GYP项目生成工具
2. V8引擎C++库
3. libuv库
4. Node内部库
5. 其他库：在deps目录下的，zlib、openssl、http_parser等

### 2.4.2 C/C++扩展模块的编写

### 2.4.3 C扩展的编译

1. 编写 binding.gyp文件
2. 调用 node-gyp configure
3. 执行 node-gyp build

生成的.node文件在 build/Release目录下

### 2.4.4 C扩展的加载

`var hello = require('./build/Release/hello.node')`

